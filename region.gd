extends Object
class_name Region

var rules

signal units_landed(landed)

var name = "testregion"

var id
#Schemes that can be bought in this region, organized by type
var schemes = {}
var scheme_cooldown = 0.0

#the amount of Attention drawn to the region
#when it reaches cap, pull some units from the region into an encounter
var attention = 0.0
var attention_to_encounter = 600.0

#Opportunities that can be found in the region, organized by type and weighted
var opportunities = {
	#"": 50,
	"domission": 10,
}

#opportunities "built in" to the region, can always be drawn regardless of situation
var base_opportunities = {
	
}

#scan progress until the next Opportunity is revealed
var opportunity_scan = 10.0
var scan_prog = 0.0

var wealth = 10

#determines heat and/or influence loss generated by units operating in this region
var security = 1

var theft_buildup = 0.0
var buildup_to_theft = 5.0
#how much greater the randomly generated buildup value is than 5. multiply wealth by this to get total cash earned
var theft_ratio = 0

#The region's Traits
var traits = []

#Maps functioning as bases in the region
var bases = []
#encounters units can be pulled into in this region, weighted
var encounters = {
	"skirmish": 10
}
#chance of actually getting an encounter when Attention gets too high
var encounter_chance = 0
#Contacts within the region
var contacts = []
#Shops in the region
var stores = []
#Active worksites in the region
var worksites = []
#Assets in the region that can be claimed
var assets = []

#raw value of influence in the region, by faction
var influence = {
	"coalition": 50.0,
	"player": 50.0
}
#percentage share of influense in the region, by faction
var influence_share = {}
#if influence goes above this amount, reduce all faction influence proportionally
var influence_cap = 100.0

#units parked in the region
var units = {}

var scheme_active = false

var tab

var encounter_active = false

func pick_encounter():
	var roll = randi() % 100
	if roll < encounter_chance:
		var options = []
		for key in encounters:
			for i in encounters[key]:
				options.append(key)
		if options != []:
			var i = randi() % options.size()
			var selected = options[i]
			return selected
	return ""
	
func random_encounter_finished(encounter, success):
	encounter_active = false
	
#pick a random encounter, then send as many units (randomly selected) as it can until the encounter is full
func random_encounter():
	var encname = pick_encounter()
	if encname != "":
		encounter_active = true
		var encounter = rules.new_encounter_by_name(encname)
		encounter.encounter_complete.connect(random_encounter_finished)
		encounter.return_map = self
		var not_selected = units.duplicate()
		for i in encounter.encounter_space:
			if not_selected != {}:
				var rand = randi() % not_selected.size()
				var unit = not_selected.values()[rand]
				not_selected.erase(unit.id)
				encounter.assign_unit(unit)
		rules.start_mission(encounter)
		pass

func _init(newrules, regiondata):
	rules = newrules
	calc_influence()

func land_units(new):
	for key in new:
		var unit = new[key]
		unit.on_map = false
		unit.map = self
	units.merge(new)
	units_landed.emit(units.values())

func remove_unit(old):
	units.erase(old.id)
	units_landed.emit(units.values())

func think(delta):
	if !scheme_active:
		if scheme_cooldown > 0:
			scheme_cooldown -= delta
		else:
			scheme_cooldown = 0
	for key in units:
		var unit = units[key]
		var infgain = 0.1 * delta
		#add_influence("player", infgain)
		scan(infgain)
		try_steal(infgain)
	attract_attention(delta)
		
func attract_attention(delta):
	if !encounter_active:
		var heat = calc_heat() * delta
		attention += heat
		if attention >= attention_to_encounter:
			attention -= attention_to_encounter
			random_encounter()

	
		
#heat is (security+1/concealment+1) for each unit
func calc_heat():
	var total = 0
	for key in units:
		var unit = units[key]
		var concealment = unit.get_concealment()
		var result = (security+1)/(concealment+1)
		total += result
	return total
	
func assign_heat(amount):
	for key in influence_share:
		var share = influence_share[key]
		var total = amount * share
		if rules.factions.has(key):
			rules.factions[key].gain_heat(total)
		
func calc_influence():
	var total = 0
	for key in influence:
		total += influence[key]
	for key in influence:
		var share = influence[key] / total
		influence_share.merge({
			key: share
		}, true)
		
func try_steal(amount):
	theft_buildup += amount
	if theft_buildup >= buildup_to_theft:
		theft_buildup -= buildup_to_theft
		determine_theft_buildup()
		steal()
		
func determine_theft_buildup():
	buildup_to_theft = randi_range(2, 20)
	theft_ratio = float(buildup_to_theft / 5.0)
		
func steal():
	var amount = wealth * theft_ratio
	rules.player.earn_intangible("cash", amount)

func scan(amount):
	scan_prog += amount
	if scan_prog > opportunity_scan:
		scan_prog -= opportunity_scan
		start_random_opportunity()
		
func start_random_opportunity():
	var opportunity = draw_opportunity()
	if opportunity != "":
		rules.start_quest(opportunity)
	else:
		pass
		
func draw_opportunity():
	var potential = []
	for key in opportunities:
		var weight = opportunities[key]
		for i in weight:
			potential.append(key)
	if potential != []:
		var i = randi() % potential.size()
		var result = potential[i]
		return result
	

func add_influence(faction, amount):
	influence.merge({
		faction: 0.0
	})
	influence[faction] += amount
	calc_influence()
	
func remove_influence(faction, amount):
	if influence.has(faction):
		influence[faction] -= amount
		if influence[faction] <= 0:
			influence.erase(faction)
	calc_influence()
